<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiu.pw</id>
    <title>秀儿</title>
    <updated>2020-09-12T00:47:26.278Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiu.pw"/>
    <link rel="self" href="https://xiu.pw/atom.xml"/>
    <subtitle>知难而退</subtitle>
    <logo>https://xiu.pw/images/avatar.png</logo>
    <icon>https://xiu.pw/favicon.ico</icon>
    <rights>All rights reserved 2020, 秀儿</rights>
    <entry>
        <title type="html"><![CDATA[优化Wordpress速度——前端使用国内免费Cdn加速Js/Css文件，后端数据库缓存]]></title>
        <id>https://xiu.pw/NiGGt4ZIu/</id>
        <link href="https://xiu.pw/NiGGt4ZIu/">
        </link>
        <updated>2020-09-11T13:44:25.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>WordPress是一个以PHP和MySQL为平台的自由开源的博客软件和内容管理系统。WordPress具有插件架构和模板系统。截至2018年4月，排名前1000万的网站中超过30.6%使用WordPress。WordPress是最受欢迎的网站内容管理系统。全球有大约30%的网站(7亿5000个)都是使用WordPress架设网站的。WordPress是目前因特网上最流行的博客系统。WordPress在最著名的网络发布阶段中脱颖而出。如今，它被使用在超过7000万个站点上。WordPress是一个以PHP和MySQL为平台的自由开源的博客软件和内容管理系统。WordPress具有插件架构和模板系统。截至2018年4月，排名前1000万的网站中超过30.6%使用WordPress。WordPress是最受欢迎的网站内容管理系统。全球有大约30%的网站(7亿5000个)都是使用WordPress架设网站的。WordPress是目前因特网上最流行的博客系统。WordPress在最著名的网络发布阶段中脱颖而出。如今，它被使用在超过7000万个站点上。</p>
</blockquote>
<p>虽然wordpress很优秀，但是当正式使用这个CMS以后，却发现很吃资源，明明博客没有多少内容，但是只要访问量一大以后，就导致WordPress打开巨慢，同时主机的使用率非常高。</p>
<p>这里就分享一些博主优化WordPress的方法。</p>
<h1 id="分离wordpress的cssjs文件">·分离WordPress的CSS/JS文件</h1>
<p>由于WordPress主要是基于PHP，同时又有大量的css/js文件需要加载。每次打开的时候都需要实时生成需要显示的网页内容，所以会比较吃主机资源。</p>
<p>这里博主推荐一款WordPress插件：commonWP</p>
<p>该插件将WordPress与大部分安装插件所需要的css/js文件通过jsdelivr分发。</p>
<p>jsdelivr目前国内是走网宿的CDN节点，国外走的CloudFlare的节点。加速效果非常明显。强烈建议该插件必备！！</p>
<p>直接WordPress后台插件安装界面搜索commonWP安装其他用即可，不用其他设定。</p>
<p>启用该插件以后，你可能会发现大部分的css/js文件都通过了jsdelivr分发，但是仍然还是有部分文件没有走jsdelivr。</p>
<p>那么这种情况下就需要你手动修改没有走jsdelivr相关的主题/插件文件了。</p>
<p><code>不建议没有动手能力的站长修改！</code></p>
<h1 id="博主这里简单说下如何修改又如何通过jsdelivr分发">博主这里简单说下如何修改，又如何通过jsdelivr分发。</h1>
<h2 id="1-修改主题或者插件引用的cssjs文件地址">1、修改主题或者插件引用的css/js文件地址</h2>
<p>首先你需要确定你要分发的内容是那个插件所需要使用的css/js文件，然后在主机上找到该插件的文件，通过分析源码，找到加载该css/js文件的内容，修改引用链接。修改后的链接后面会说如何获取。</p>
<p>例如本站有使用auto-highslide，该插件就不会自动被commonWP修改成jsdelivr的地址，那么通过分析该插件的文件，找到是通过auto-highslide.php加载的相关css/js文件。</p>
<p>在auto-highslide.php文件里面，发现</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;'.get_bloginfo('wpurl').'/wp-content/plugins/auto-highslide/highslide/highslide.css&quot; type=&quot;text/css&quot; /&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;'.get_bloginfo('wpurl').'/wp-content/plugins/auto-highslide/highslide/highslide-with-html.packed.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
</code></pre>
<p>那么需要修改的就是</p>
<pre><code>href=&quot;'.get_bloginfo('wpurl').'/wp-content/plugins/auto-highslide/highslide/highslide.css&quot;
</code></pre>
<p>和</p>
<pre><code class="language-javascript">src=&quot;'.get_bloginfo('wpurl').'/wp-content/plugins/auto-highslide/highslide/highslide-with-html.packed.js&quot;
</code></pre>
<p>修改成</p>
<pre><code>href=&quot;https://cdn.jsdelivr.net/gh/Loukky/wpcdn@40028ba1e2ff8193194f9c1474d81ed5d26c52eb/themes/highslide.css&quot;
</code></pre>
<p>和</p>
<pre><code>src=&quot;https://cdn.jsdelivr.net/gh/Loukky/wpcdn@249a403710b0739bf5173cd9d7afeefd04b12eb0/themes/highslide-with-html.packed.js&quot;
</code></pre>
<p>那么完整的代码就是：</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/gh/Loukky/wpcdn@40028ba1e2ff8193194f9c1474d81ed5d26c52eb/themes/highslide.css&quot; type=&quot;text/css&quot; /&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.jsdelivr.net/gh/Loukky/wpcdn@249a403710b0739bf5173cd9d7afeefd04b12eb0/themes/highslide-with-html.packed.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
</code></pre>
<p>其他的插件与主题修改方法与之类似，另外WP自带的函数是通过 wp_enqueue_style和wp_enqueue_scripts加载CSS和JS文件的，如果是修改主题的话，注意这两个函数。</p>
<h2 id="2-手动通过jsdelivr分发文件">2、手动通过jsdelivr分发文件</h2>
<p>该方法需要通过github来操作，在GitHub上面新建一个仓库，注意仓库设置成public。上传你需要分发的内容，然后通过jsdelivr来分发，具体操作这里不多说。</p>
<p>jsdelivr分发github文件的规则这里说下。</p>
<p>https://cdn.jsdelivr.net/gh/GitHub用户名/仓库名/文件.后缀</p>
<p>注意GitHub区分大小写，其他仓库名后面可以通过@来指定具体的某个release版本或者修订版本。</p>
<h1 id="缓存数据库">·缓存数据库</h1>
<p>一般现在用得较多的数据库缓存是memcached和redis，博主使用的是redis，以redis为例，由于博主是通过宝塔安装的php，所以这里也以宝塔为例。</p>
<p>在宝塔的php管理界面，找到安装扩展，里面有个redis，通过该路径来安装redis，然后wp后台安装上redis相关的插件。博主这里使用的是Redis Object Cache</p>
<p>安装好以后就启用插件，简单设置下就可以了。</p>
<p>（可选）然后在宝塔管理界面，选择mysql管理界面。里面有个性能调整。根据你的实际使用情况调整相关参数。</p>
<figure data-type="image" tabindex="1"><img src="https://loukky.com/wp-content/uploads/2020/08/082615014568_0QQ%E6%88%AA%E5%9B%BE20200826150049.png" alt="" loading="lazy"></figure>
<p>通过上面设置与调整过后，那么现在你的WordPress应该是可以明显感觉到速度提升了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CloudFront扫段Pyhon脚本]]></title>
        <id>https://xiu.pw/iNkGyc0K_/</id>
        <link href="https://xiu.pw/iNkGyc0K_/">
        </link>
        <updated>2020-09-10T02:45:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="使用方法">使用方法：</h1>
<pre><code>python cfscan.py 183.201.1.1-183.201.255.255 800

cfscan.py = 你保存的文件名

183.201.1.1-183.201.255.255 = 你要扫的起始IP-结尾IP

800 = 线程数
</code></pre>
<h1 id="运行截图">运行截图：</h1>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/09/10/aK6zJFCNrY4Ah9m.png" alt="" loading="lazy"></figure>
<h1 id="结果截图">结果截图：</h1>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2020/09/10/ipcu5gzH1LDn6WY.png" alt="" loading="lazy"></figure>
<h1 id="脚本代码">脚本代码：</h1>
<pre><code>#!/usr/bin/env python
# coding=utf-8
# python2.7 only

import threading
import requests
import Queue
import sys
import re

#ip to num
def ip2num(ip):
    ip = [int(x) for x in ip.split('.')]
    return ip[0] &lt;&lt; 24 | ip[1] &lt;&lt; 16 | ip[2] &lt;&lt; 8 | ip[3]

#num to ip
def num2ip(num):
    return '%s.%s.%s.%s' % ((num &amp; 0xff000000) &gt;&gt; 24,(num &amp; 0x00ff0000) &gt;&gt; 16,(num &amp; 0x0000ff00) &gt;&gt; 8,num &amp; 0x000000ff)

#
def ip_range(start, end):
    return [num2ip(num) for num in range(ip2num(start), ip2num(end) + 1) if num &amp; 0xff]

#
def bThread(iplist):
   
    threadl = []
    queue = Queue.Queue()
    for host in iplist:
        queue.put(host)

    for x in xrange(0, int(SETTHREAD)):
        threadl.append(tThread(queue))
        
    for t in threadl:
        t.start()
    for t in threadl:
        t.join()        

#create thread
class tThread(threading.Thread):
    def __init__(self, queue):
        threading.Thread.__init__(self)
        self.queue = queue

    def run(self):
        
        while not self.queue.empty():
            host = self.queue.get()
            try:
                checkServer(host)
            except:
                continue

def checkServer(host):
    header ={'user-agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36'}
    aimurl = &quot;http://&quot;+host+&quot;:443&quot;
    response = requests.get(url=aimurl,headers=header,timeout=10)
    serverText = response.headers['server']

    if len(serverText) &gt; 0:
        print  &quot;-&quot;*50+&quot;\n&quot;+aimurl +&quot;\nServer: &quot;+serverText
        if (serverText == &quot;CloudFront&quot;):
            f.write(host+&quot;\n&quot;)


if __name__ == '__main__':
    print '\n############# Cloud Front Scan  ################'
    print '                Author hostloc.com'
    print '################################################\n'

    global SETTHREAD

    try:
        SETTHREAD = sys.argv[2]
        f = open(&quot;result.txt&quot;, &quot;w&quot;)
        iplist = ip_range(sys.argv[1].split('-')[0], sys.argv[1].split('-')[1])
        
        print '\n[Note] Will scan '+str(len(iplist))+&quot; host...\n&quot;

        bThread(iplist)
    except KeyboardInterrupt:
        print 'Keyboard Interrupt!'
        sys.exit()</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[页内和页外SEO技术]]></title>
        <id>https://xiu.pw/73lF-bANp/</id>
        <link href="https://xiu.pw/73lF-bANp/">
        </link>
        <updated>2020-09-03T04:48:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="搜索引擎优化不会消失-随着搜索越来越根深蒂固地融入到人们兴趣的问题和信息答案的方式中-但seo是很棘手的游戏总是改变从来没有简单-那么当涉及到排名时如何保持领先呢">搜索引擎优化不会消失。随着搜索越来越根深蒂固地融入到人们兴趣的问题和信息答案的方式中。但SEO是很棘手的游戏，总是改变，从来没有简单。那么，当涉及到排名时，如何保持领先呢？</h2>
<h2 id="seo-由两个部门组成页面外和页面">SEO 由两个部门组成：页面外和页面。</h2>
<ul>
<li><strong>页面外SEO是指您的网站在搜索引擎眼中拥有的权威</strong></li>
<li><strong>网页SEO是指网站本身的内容和结构</strong></li>
</ul>
<p><em>对非页面和页面搜索引擎优化的强烈关注将在网站的排名和流量方面，并将直接影响收入、销售、转化和客户的获取</em>。</p>
<h1 id="页面外seo优化">页面外SEO优化</h1>
<ul>
<li>
<p>技巧开发的内容，很容易共享。内容是 SEO 的王道。开发高质量内容，方便推荐网页的实际人员中自然生成反向链接。</p>
</li>
<li>
<p>尽可能经常外联。从他们的博客中留言并申请反向链接。</p>
</li>
<li>
<p>你可以从社交媒体渠道获得很多的社交信息和自然链接，以及增加来自社交引用来源的流量。</p>
</li>
<li>
<p>多媒体来源的链接也是实现链接配置文件多样化的一个很好的方式。利用YouTube和其他视频共享网站，并在描述中添加链接（如果适用）。利用Imgur和其他图像共享网站，并在描述中再次添加链接（如果适用）。播客以及其他音频网站。文档共享网站（如 Slideshare 和Web 2.0）的&quot;中等&quot;网站也一样。</p>
</li>
<li>
<p>最近流行的抓流量和反向链接的方法之一来自网站，如Quora和其他问答引擎。查找与业务和主题相关的问题，并提供简洁、清晰的问题的答案。令人惊讶的是， 有足够的参与度， Quora 上的无跟随反向链接可以跟随。</p>
</li>
<li>
<p>避免过度优化关键字。如果您选择仅定位完全匹配的关键字，则链接构建中可能会遇到问题，因为它与您的排名相关。在我看来，90%左右应该是通用和品牌关键字，以及一些赤裸裸的网址。请记住，在构建链接时，尽可能自然地显示非常重要。只有大约 5% 的会针对选择定位的精确匹配短语。</p>
</li>
<li>
<p>对于网站是实时和成长阶段头三个月，我将专注于通用和品牌词。瞄准尽可能多的品牌词，如搜索引擎，如品牌。使您的网站看起来像一个品牌。在此之后，我慢慢地开始添加裸网址、LSI 变体和完全匹配的关键字的组合。</p>
</li>
</ul>
<h1 id="专注于页面优化页面">专注于页面优化页面</h1>
<p>优化是指可以在您控制的网站属性的页面上进行的更改和增强。如果执行得当，页面 SEO 可以简单得多、更有效，并且需要的研究比页面外优化少得多。</p>
<ul>
<li>
<p>精确匹配词出现在标题</p>
</li>
<li>
<p>搜索引擎需要知道您的网页是关于什么的</p>
</li>
<li>
<p>确保您尝试排名的主要关键字位于文章的标题中，这一点至关重要。很少有搜索结果中缺少标题中的主关键字会排名该关键字或相关的 LSI 长尾</p>
</li>
<li>
<p>关键字之间 SEO 价值， 哪些是最好标题中的关键字</p>
</li>
<li>
<p>在描述中是唯一的，使用主关键字</p>
</li>
<li>
<p>页面标题（搜索引擎看到）应不超过 50 到 60 个字符（如果可能）。</p>
</li>
<li>
<p>同时，您不希望标题显示的信息太少，不会造成混淆。页面的元描述应限制大约 150个字符。这将确保您不会在搜索结果中被截断。</p>
</li>
<li>
<p>使用关键字和 Lsi 变体在标题标签文本</p>
</li>
<li>
<p>标题标签告诉搜索引擎您的内容概述。它们从 H1（最大，通常是标题标签）到 H6。文章和帖子中最常用的标签是 H2 和 H3。如果完全不使用标题标记，则爬虫很识别您的文章内容，并且您的帖子结构将遭受人类访问者的影响。</p>
</li>
<li>
<p>最佳做法是考虑 H1 标题，H2 主节标题，然后 H3 考虑子节标题。在这些标题标记中使用 LSI 关键字的变体非常重要。LSI 代表潜在的语义索引，这是一个系统搜索引擎，用于分析人们围绕给定主题使用的其他词。LSIGraph 是一个可靠的免费工具，用于发现 LSI 关键字，这些关键字与目标关键字类似，但更集中且搜索量较低。</p>
</li>
<li>
<p>网站速度的重要性是至关重要的，页面搜索引擎优化最关键的部分之一是网站加载速度。</p>
</li>
<li>
<ul>
<li>提高网站速度的一些最佳方法包括： 提高网站速度的一些最佳方法包括：<br>
使用 Gzip 等工具在现场启用压缩。<br>
优化ML和JavaScript。<br>
减少站点上的重定向数。<br>
删除呈现阻止 JavaScript。<br>
利用浏览器的缓存。<br>
提高服务器的响应时间。<br>
利用 CDN 或内容分发网络。<br>
执行高质量的图像优化。</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在同一个虚拟主机空间优雅地安装多个网站]]></title>
        <id>https://xiu.pw/ZZXDhqj85/</id>
        <link href="https://xiu.pw/ZZXDhqj85/">
        </link>
        <updated>2020-09-02T07:13:22.000Z</updated>
        <content type="html"><![CDATA[<p>如何在同一个虚拟主机空间优雅地安装多个网站</p>
<pre><code> &lt;?php
    switch ($_SERVER[&quot;HTTP_HOST&quot;])
    {
        case &quot;www.uselys.com&quot;:
                            header(&quot;location:.com&quot;);
        break;
        case &quot;www.uselys.cn&quot;:
                            header(&quot;location:.cn&quot;);
        break;
        case &quot;www.panyh.net&quot;:
                            header(&quot;location:panyh&quot;);
        break;
    }
    ?&gt;
</code></pre>
<p>也就是在根目录 / 下放一个 index.php，然后根据域名分别跳转到对应的子目录下，实现同一个空间安装多个网站的办法。</p>
<p>但这种方法毕竟有点拖沓，于是有了另一段代码：</p>
<pre><code>RewriteEngine on

DirectoryIndex index.html index.htm index.php default.php index.cgi

# 条件：如果所访问的目标既不是文件，也不是目录
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d

# 那么：

###########################  第一段 ########################
# 把 /uselys.cn/ 作为 www.uselys.cn 的根目录
# 如果主机为 www.uselys.cn 并且 uri 不以 /uselys.cn/ 作为开头
RewriteCond %{HTTP_HOST} www.uselys.cn
RewriteCond %{REQUEST_URI} !^/uselys.cn/
#那么，就把网址里所有的文件都跳转到 /uselys.cn/下对应的内容：
RewriteRule ^(.*)$ /uselys.cn/$1
# 如果主机为 www.uselys.cn
RewriteCond %{HTTP_HOST} www.uselys.cn
#那么，就把默认首页 / 跳转到 /uselys.cn/index.php文件，并结束跳转
RewriteRule ^(/)?$ uselys.cn/index.php [L]

###########################  第二段 ########################

RewriteCond %{HTTP_HOST} ^www.uselys.com$
RewriteCond %{REQUEST_URI} !^/uselys.com/
RewriteRule ^(.*)$ /uselys.com/$1
RewriteCond %{HTTP_HOST} ^www.uselys.com$
RewriteRule ^(/)?$ uselys.com/index.php [L]

###########################  第三段 ########################

RewriteCond %{HTTP_HOST} ^www.panyh.net$
RewriteCond %{REQUEST_URI} !^/panyh.net/
RewriteRule ^(.*)$ /panyh.net/$1
RewriteCond %{HTTP_HOST} ^www.panyh.net$
RewriteRule ^(/)?$ panyh.net/ [L]

# ... 以此类推
</code></pre>
<p>这是一段 apache的配置文件。当前所有Linux虚拟空间和全能空间都会支持 .htaccess 配置吧。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用Microsoft 365 E5开发者订阅搭建自己的邮局|设置catch-all邮箱]]></title>
        <id>https://xiu.pw/gsDFY9Jro/</id>
        <link href="https://xiu.pw/gsDFY9Jro/">
        </link>
        <updated>2020-08-30T15:55:27.000Z</updated>
        <content type="html"><![CDATA[<p>最近看了几个服务器自建邮局的方案，很多程序服务器要求2G内存起步，搭建也比较复杂，还要各种设置避免进垃圾箱，是个技术活，害怕那步出问题搞的自己心态爆炸，感觉不太适合自己。想想还是第三方的好，之前我已经尝试过yandex/zoho/腾讯企业邮，最后选择了yandex，一直再使用感觉良好。前几天开发者试用的E5订阅又续订，于是就试了一下，设置邮局功能按照后台引导设置没有任何难度，主要是设置catch-all邮箱，这里分享一下过程。</p>
<p>提示：文中E5订阅是指开发者试用订阅，保持活跃能自动续费。网上有很多调用api保持活跃的方法，但是博主申请完一直没使用也续费了，如何才算活跃没有具体的说法。如果没有自动续费，订阅会被取消但是数据不是马上删除，会有时间可以迁移 。</p>
<p>（本文搭建邮局不是开发行为，只是正常使用。）</p>
<p><strong>catch-all邮箱</strong>：又叫全收邮件，就是把发给邮件服务器上不存在账户的邮件都重定向到某个邮箱，而不是直接退信。正常情况下，如发邮件给服务器上不存在的账户会直接退信给发件人。E5开发者订阅只用25用户，利用catch-all功能可以实现无限别名收邮件。</p>
<h1 id="一添加域名到microsoft-365">一，添加域名到Microsoft 365</h1>
<p>打开：https://admin.microsoft.com/Adminportal/Home?source=applauncher#/Domains<br>
添加并验证域名，前两步我就不截图了。</p>
<p><img src="http://blog.jialezi.net/admin/editor/php/upload/46231593341187.png" alt="" loading="lazy"><br>
<img src="http://blog.jialezi.net/admin/editor/php/upload/74411593341187.png" alt="" loading="lazy"><br>
<img src="http://blog.jialezi.net/admin/editor/php/upload/38461593341187.png" alt="" loading="lazy"><br>
<img src="http://blog.jialezi.net/admin/editor/php/upload/77251593341187.png" alt="" loading="lazy"><br>
<img src="http://blog.jialezi.net/admin/editor/php/upload/79951593341187.png" alt="" loading="lazy"></p>
<h1 id="二添加两个用户用于测试">二，添加两个用户用于测试</h1>
<p>添加用户：https://admin.microsoft.com/Adminportal/Home?source=applauncher#/users</p>
<p>添加了i@9mail.club和aaa@9mail.club</p>
<p><img src="http://blog.jialezi.net/admin/editor/php/upload/70031593341187.png" alt="" loading="lazy"><br>
<img src="http://blog.jialezi.net/admin/editor/php/upload/25201593341187.png" alt="" loading="lazy"></p>
<h1 id="三向i9mailclub和i29mailclub不存在的用户发送邮件">三，向i@9mail.club和i2@9mail.club（不存在的用户）发送邮件</h1>
<p>可见i2@9mail.club是退信了。<br>
<img src="http://blog.jialezi.net/admin/editor/php/upload/30121593341188.png" alt="" loading="lazy"><br>
<img src="http://blog.jialezi.net/admin/editor/php/upload/81921593341188.png" alt="" loading="lazy"></p>
<h1 id="四设置catch-all功能">四，设置Catch-all功能。</h1>
<p>1）打开Exchange 管理中心：https://outlook.office365.com/ecp/</p>
<figure data-type="image" tabindex="1"><img src="http://blog.jialezi.net/admin/editor/php/upload/32321593341188.png" alt="" loading="lazy"></figure>
<p>2）修改域类型</p>
<p>邮件流——接受的域，把域类型改为内部中继。</p>
<p><img src="http://blog.jialezi.net/admin/editor/php/upload/48211593341188.png" alt="" loading="lazy"><br>
<img src="http://blog.jialezi.net/admin/editor/php/upload/86391593341188.png" alt="" loading="lazy"></p>
<p>3）创建一个动态通讯组，用于存放已有的用户。</p>
<p>收件人——组——新建Office 365组——动态通讯组列表——仅以下收件人类型——具有Exchange邮箱用户</p>
<p>（我这里动态通讯组名称设置为 exchange）</p>
<figure data-type="image" tabindex="2"><img src="http://blog.jialezi.net/admin/editor/php/upload/68331593341188.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="http://blog.jialezi.net/admin/editor/php/upload/63721593341188.png" alt="" loading="lazy"></figure>
<p>4）创建规则，用于把不存在有的邮件重定向到指定邮箱</p>
<p>邮件流——规则——创建新规则</p>
<p>名称:随意——规则：发件人位于 组织外部 ——执行：邮件重定向 指定邮箱（i@9mail.club）</p>
<p>除非：收件人为以下组成员 exchange（第三步设置的动态通讯组） PS：如果看不到除非选项，请滑动到底部点击下面的高级</p>
<figure data-type="image" tabindex="4"><img src="http://blog.jialezi.net/admin/editor/php/upload/35851593341188.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="http://blog.jialezi.net/admin/editor/php/upload/60301593341188.png" alt="" loading="lazy"></figure>
<h1 id="五测试">五，测试</h1>
<p>向aaa@9mail.club和xxx@9mail.club（不存在）发送邮件</p>
<p>aaa@9mail.club正常收到邮件</p>
<p>xxx@9mail.club的邮件重定向到了i@9mail.club</p>
<p>设置成功。</p>
<figure data-type="image" tabindex="6"><img src="http://blog.jialezi.net/admin/editor/php/upload/1401593341188.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="http://blog.jialezi.net/admin/editor/php/upload/14001593341189.png" alt="" loading="lazy"></figure>
<p>转自:<a href="http://blog.jialezi.net/?post=158" title="http://blog.jialezi.net/?post=158">http://blog.jialezi.net/?post=158</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Onedrive+OneManager+Heroku+CFWorkers免费的OD列表]]></title>
        <id>https://xiu.pw/KB2M1bDsU/</id>
        <link href="https://xiu.pw/KB2M1bDsU/">
        </link>
        <updated>2020-08-30T01:39:37.000Z</updated>
        <content type="html"><![CDATA[<p><strong>网站下载链接直接是xxx.com/abc.jpg，没有302跳到微软xxx.sharepoint.com，也没有反代xxx.sharepoint.com那样后面一长串。</strong></p>
<h1 id="准备工作">准备工作：</h1>
<p>1，        Onedrive，或Sharepoint<br>
这个大家有的，各种A1，E3，E5，世纪。（Sharepoint默认25T）<br>
2，        OneManager，Github地址：https://github.com/qkqpttgf/OneManager-php<br>
基于各种无服务器的平台，比如Heroku、腾讯SCF、阿里FC、华为FG、百度CFC，配置都保存在其环境变量中，当然也可以装在VPS与空间里，不过为了一致，程序不固定储存onedrive的目录结构，缓存最多1小时<br>
3，        Heroku，最好需要注册2个帐号，注册与登录时需要魔法，平时操作时不需要<br>
OneManager配置是保存在环境变量中的，所以不需要一直监控保活，Heroku免费套餐每月550小时，550小时/30天=18.33小时，每天只要访问时间段空出来24-18=6小时没有人访问，这一个月其实就足够使用了，但有些人的网站可能访问人比较多所以还没到月底就用光了。<br>
当然，heroku也可绑卡达到1000小时，同时还能自定义域名。但，SSL却比较麻烦。<br>
4，        CF workers，免费的就好</p>
<h1 id="部署程序-安装程序-绑定网盘">部署程序、安装程序、绑定网盘：</h1>
<p>1，        将OneManager一键部署到Heroku<br>
2，        访问给定的herokuapp域名，正式安装好程序<br>
3，        安装好后登录，在设置中绑定Onedrive或Sharepoint<br>
4，        在设置中做些设定<br>
5，        换一个Heroku帐号再安装一次（时长够用就无所谓）</p>
<h1 id="重点">重点：</h1>
<p><strong>在CF Workers中填入以下代码</strong></p>
<hr>
<pre><code>// 单日
const SingleDay = '111.herokuapp.com'
// 双日
const DoubleDay = '222.herokuapp.com'
// 一切给CF代理，true/false
const CFproxy = true

// 由于heroku不绑卡不能自定义域名，就算绑卡后https也不方便
// 另外免费套餐每月550小时，有些人不够用
// 于是在CF Workers使用此代码，分单双日拉取不同heroku帐号下的相同网页
// 只改上面，下面不用动

addEventListener('fetch', event =&gt; {
    let nd = new Date();
    if (nd.getDate()%2) {
        host = SingleDay
    } else {
        host = DoubleDay
    }
    if (!CFproxy) {
        let url=new URL(event.request.url);
        if (url.protocol == 'http:') {
            url.protocol = 'https:'
            response = Response.redirect(url.href);
            event.respondWith( response );
        } else {
            url.hostname=host;
            let request=new Request(url,event.request);
            event.respondWith( fetch(request) )
        }
    } else {
        event.respondWith( fetchAndApply(event.request) );
    }
})

async function fetchAndApply(request) {
    let response = null;
    let url = new URL(request.url);
    if (url.protocol == 'http:') {
        url.protocol = 'https:'
        response = Response.redirect(url.href);
        return response;
    }
    url.host = host;

    let method = request.method;
    let body = request.body;
    let request_headers = request.headers;
    let new_request_headers = new Headers(request_headers);

    new_request_headers.set('Host', url.host);
    new_request_headers.set('Referer', request.url);

    let original_response = await fetch(url.href, {
        method: method,
        body: body,
        headers: new_request_headers
    });

    response = new Response(original_response.body, {
        status: original_response.status,
        headers: original_response.headers
    })

    return response;
}
</code></pre>
<hr>
<p>单双日分别填入不同的heroku帐号下的网站（当然2个网站要设置得一模一样），这样每个heroku帐号每个月都只访问15或16天，就算24小时有人访问也才360或384小时。<br>
最后，给workers加上自定义域名的路由！</p>
<p>从头到尾都可以是Free的，不看网站页面，光从下载过程来看，可以完全假装CF套在了大盘鸡上,谁也看不出我没服务器。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[INFO-SPIDER 是一个帮助用户拿回自己的数据的爬虫工具箱]]></title>
        <id>https://xiu.pw/UM09GDy1m/</id>
        <link href="https://xiu.pw/UM09GDy1m/">
        </link>
        <updated>2020-08-29T13:14:31.000Z</updated>
        <content type="html"><![CDATA[<p><strong>一个神奇的工具箱，拿回你的个人信息。</strong></p>
<h1 id="what-is-info-spider">What is INFO-SPIDER</h1>
<p>INFO-SPIDER 是一个集众多数据源于一身的爬虫工具箱，旨在安全快捷的帮助用户拿回自己的数据，工具代码开源，流程透明。并提供数据分析功能，基于用户数据生成图表文件，使得用户更直观、深入了解自己的信息。 目前支持数据源包括GitHub、QQ邮箱、网易邮箱、阿里邮箱、新浪邮箱、Hotmail邮箱、Outlook邮箱、京东、淘宝、支付宝、中国移动、中国联通、中国电信、知乎、哔哩哔哩、网易云音乐、QQ好友、QQ群、生成朋友圈相册、浏览器浏览历史、12306、博客园、CSDN博客、开源中国博客、简书。</p>
<h1 id="features">Features</h1>
<p>安全可靠：本项目为开源项目，代码简洁，所有源码可见，本地运行，安全可靠。<br>
使用简单：提供 GUI 界面，只需点击所需获取的数据源并根据提示操作即可。<br>
结构清晰：本项目的所有数据源相互独立，可移植性高，所有爬虫脚本在项目的 Spiders 文件下。<br>
数据源丰富：本项目目前支持多达24+个数据源，持续更新。<br>
数据格式统一：爬取的所有数据都将存储为json格式。<br>
个人数据丰富：本项目将尽可能多地为你爬取个人数据，后期数据处理可根据需要删减。<br>
数据分析：本项目提供个人数据的可视化分析，目前仅部分支持。<br>
文档丰富：本项目包含完整全面的使用说明文档和视频教程</p>
<h1 id="quickstart">QuickStart</h1>
<h2 id="依赖安装">依赖安装</h2>
<p>安装python3和Chrome浏览器</p>
<p>安装与Chrome浏览器相同版本的<a href="http://chromedriver.storage.googleapis.com/index.html" title="驱动">驱动</a></p>
<p>安装依赖库 pip install -r requirements.txt</p>
<h2 id="工具运行">工具运行</h2>
<p>进入 tools 目录</p>
<p>运行 python3 main.py</p>
<p>在打开的窗口点击数据源按钮, 根据提示选择数据保存路径</p>
<p>弹出的浏览器输入用户密码后会自动开始爬取数据, 爬取完成浏览器会自动关闭.</p>
<p>在对应的目录下可以查看下载下来的数据(xxx.json), 数据分析图表(xxx.html)</p>
<h1 id="数据源">数据源</h1>
<p>GitHub<br>
QQ邮箱<br>
网易邮箱<br>
阿里邮箱<br>
新浪邮箱<br>
Hotmail邮箱<br>
Outlook邮箱<br>
京东<br>
淘宝<br>
支付宝<br>
中国移动<br>
中国联通<br>
中国电信<br>
知乎<br>
哔哩哔哩<br>
网易云音乐<br>
QQ好友<br>
QQ群<br>
生成朋友圈相册<br>
浏览器浏览历史<br>
12306<br>
博客园<br>
CSDN博客<br>
开源中国博客<br>
简书</p>
<h1 id="数据分析">数据分析</h1>
<p>博客园</p>
<p>CSDN博客</p>
<p>开源中国博客</p>
<p>简书</p>
<h1 id="计划">计划</h1>
<p>提供web界面操作，适应多平台</p>
<p>对爬取的个人数据进行统计分析</p>
<p>融合机器学习技术、自然语言处理技术等对数据深入分析</p>
<p>把分析结果绘制图表直观展示</p>
<p>添加更多数据源...</p>
<p>Visitors</p>
<h1 id="developers-want-to-say">Developers want to say</h1>
<ol>
<li>该项目解决了个人数据分散在各种各样的公司之间，经常形成数据孤岛，多维数据无法融合的痛点。</li>
<li>作者认为该项目的最大潜力在于能把多维数据进行融合并对个人数据进行分析，是个人数据效益最大化。</li>
<li>该项目使用爬虫手段获取数据，所以程序存在时效问题（需要持续维护，根据网站的更新做出修改）。</li>
<li>该项目的结构清晰，所有数据源相互独立，可移植性高，所有爬虫脚本在项目的Spiders文件下，可移植到你的程序中。</li>
<li>目前该项目v1.0版本仅在Windows平台上测试，Python 3.7，未适配多平台。</li>
<li>计划在v2.0版本对项目进行重构，提供web端操作与数据可视化，以适配多平台。</li>
<li><strong>本项目<a href="https://github.com/kangvcar/InfoSpider" title="INFO-SPIDER">INFO-SPIDER</a>代码已开源，欢迎star支持。</strong></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vps测速整合脚本]]></title>
        <id>https://xiu.pw/E-ilBDDMb/</id>
        <link href="https://xiu.pw/E-ilBDDMb/">
        </link>
        <updated>2020-08-27T12:24:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="使用方法">使用方法:</h1>
<pre><code class="language-bash">wget vpstest.cn/it &amp;&amp; bash it
</code></pre>
<p>或</p>
<pre><code class="language-bash">wget git.io/vpstest &amp;&amp; bash vpstest
</code></pre>
<p>或</p>
<pre><code class="language-bash">wget -O it vpstest.cn &amp;&amp; bash it
</code></pre>
<h1 id="效果图">效果图</h1>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/08/25/d2msj1.png" alt="" loading="lazy"></figure>
<pre><code>整合了
1. bench.sh
2. LemonBench
3. superspeed
4. superbench修复版
5. 91yuntest
6. ZBench
7. superbench修复+多节点版
8. UnixBench
9. GeekBench5
10.kos回程测试
11.超内存测试
12.sysbench测试---感谢云筏大佬的分享
路由测试
（注：脚本收集自互联网）
已修复kos测试
已更新删除残留文件
修复了一些已知bug
已经修复脚本4、7（有待测试）
请删除脚本残余文件
添加sysbench-cpu测试
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[监测IP是否被阻断]]></title>
        <id>https://xiu.pw/uxQvbeATH/</id>
        <link href="https://xiu.pw/uxQvbeATH/">
        </link>
        <updated>2020-08-27T12:19:33.000Z</updated>
        <content type="html"><![CDATA[<h1 id="监测ip是否被阻断">监测IP是否被阻断</h1>
<p>利用 PHP socket 去监测指定 域名/IP 的 TCP 和 ICMP 是否开放.</p>
<p>请开启 exec() 函数.</p>
<p>测试环境为:宝塔面板 PHP7.0+ nginx1.15</p>
<p>请安装 PHP socket 扩展(宝塔面板默认是安装的),否则无法使用哦</p>
<pre><code>已知问题在Linux下 socket 检测 icmp,会没有权限.现只能用 exec() 函数
</code></pre>
<h1 id="部署方法">部署方法</h1>
<p>把 check.php 分别放到国内服务器和国外服务器.</p>
<p>修改 index.html 的GET 请求地址即可.<br>
<img src="https://mjj.today/temp/1910/ec034efc07983847.png" alt="" loading="lazy"></p>
<h1 id="预览">预览</h1>
<figure data-type="image" tabindex="1"><img src="https://cdn.u1.huluxia.com/g3/M01/E9/0A/wKgBOV2b8heARHU7AAAvxkpyM1M813.png" alt="" loading="lazy"></figure>
<h1 id="项目地址"><a href="https://gitee.com/KIENG_S/jianchaipshifouzuduan" title="项目地址">项目地址</a></h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Github Action定时重启IBM cloud foundry]]></title>
        <id>https://xiu.pw/ZfBq1liZd/</id>
        <link href="https://xiu.pw/ZfBq1liZd/">
        </link>
        <updated>2020-08-26T06:26:20.000Z</updated>
        <content type="html"><![CDATA[<p><strong>本文简单介绍了Github Action的用法，并使用Gihub Action定时重启IBM cloud foundry容器。</strong></p>
<h1 id="摘要">摘要</h1>
<p><strong>GitHub Actions是GitHub自家的持续集成及自动化工作流服务，它使用起来非常简单，只要在你的仓库根目录建立.github/workflows文件夹，将你的工作流配置(YML文件)放到这个目录下，就能启用GitHub Actions服务。</strong></p>
<h1 id="关键字">关键字</h1>
<p><strong>Github Action，IBM cloud foundry</strong></p>
<h1 id="yml配置文件">yml配置文件</h1>
<pre><code class="language-php">name: IBM Cloud Auto Restart

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]
  schedule:
    - cron: '0 0 * * *'      # 根据自己的需要设置何时重启

jobs:
  ibm-cloud-restart:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2

    - name: Init
      run: |
        wget -q -O - https://packages.cloudfoundry.org/debian/cli.cloudfoundry.org.key | sudo apt-key add -
        echo &quot;deb https://packages.cloudfoundry.org/debian stable main&quot; | sudo tee /etc/apt/sources.list.d/cloudfoundry-cli.list
        sudo apt-get update
        sudo apt-get install cf-cli
    - name: Login IBM Cloud
      env:
        IBM_ACCOUNT: ${{ secrets.IBM_ACCOUNT }}
        IBM_PASSWORD: ${{ secrets.IBM_PASSWORD }}
      run: |
        cf login -a https://api.us-south.cf.cloud.ibm.com -u $IBM_ACCOUNT &lt;&lt; EOF
        $IBM_PASSWORD
        EOF
    - name: Get IBM Cloud Apps
      run: |
        cf a
    - name: Restart IBM Cloud
      env:
        IBM_APP_NAME: ${{ secrets.IBM_APP_NAME }}
      run: |
        cf restart $IBM_APP_NAME
</code></pre>
<h1 id="使用方法">使用方法</h1>
<p>fork仓库：https://github.com/wf09/IBMWorkflow</p>
<h1 id="设置环境变量">设置环境变量</h1>
<pre><code>IBM_ACCOUNT：账户邮箱

IBM_APP_NAME：app的名字

IBM_PASSWORD：密码
</code></pre>
<p><strong>设置完环境变量以后记得commit一下yml文件触发Action。</strong></p>
<h1 id="效果图">效果图</h1>
<figure data-type="image" tabindex="1"><img src="https://ftp.fly97.cn/image/image-20200827193322808.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>